use textcode::*;

#[test]
fn test_iso6937() {
    struct TestData {
        encoded: &'static [u8],
        decoded: &'static str,
    }

    let tests = &[
        TestData {
            encoded: &[0x69, 0x73, 0x6f, 0x36, 0x39, 0x33, 0x37, 0x0a],
            decoded: "iso6937\n",
        },
        TestData {
            encoded: &[0xa4, 0xd5],
            decoded: "â‚¬â™ª",
        },
        TestData {
            encoded: &[
                0xc1, 0x41, 0xc1, 0x45, 0xc1, 0x49, 0xc1, 0x4f, 0xc1, 0x55, 0xc1, 0x61, 0xc1, 0x65,
                0xc1, 0x69, 0xc1, 0x6f, 0xc1, 0x75,
            ],
            decoded: "Ã€ÃˆÃŒÃ’Ã™Ã Ã¨Ã¬Ã²Ã¹",
        },
        TestData {
            encoded: &[
                0xc2, 0x41, 0xc2, 0x43, 0xc2, 0x45, 0xc2, 0x49, 0xc2, 0x4c, 0xc2, 0x4e, 0xc2, 0x4f,
                0xc2, 0x52, 0xc2, 0x53, 0xc2, 0x55, 0xc2, 0x59, 0xc2, 0x5a, 0xc2, 0x61, 0xc2, 0x63,
                0xc2, 0x65, 0xc2, 0x67, 0xc2, 0x69, 0xc2, 0x6c, 0xc2, 0x6e, 0xc2, 0x6f, 0xc2, 0x72,
                0xc2, 0x73, 0xc2, 0x75, 0xc2, 0x79, 0xc2, 0x7a,
            ],
            decoded: "ÃÄ†Ã‰ÃÄ¹ÅƒÃ“Å”ÅšÃšÃÅ¹Ã¡Ä‡Ã©Ä£Ã­ÄºÅ„Ã³Å•Å›ÃºÃ½Åº",
        },
        TestData {
            encoded: &[
                0xc3, 0x41, 0xc3, 0x43, 0xc3, 0x45, 0xc3, 0x47, 0xc3, 0x48, 0xc3, 0x49, 0xc3, 0x4a,
                0xc3, 0x4f, 0xc3, 0x53, 0xc3, 0x55, 0xc3, 0x57, 0xc3, 0x59, 0xc3, 0x61, 0xc3, 0x63,
                0xc3, 0x65, 0xc3, 0x67, 0xc3, 0x68, 0xc3, 0x69, 0xc3, 0x6a, 0xc3, 0x6f, 0xc3, 0x73,
                0xc3, 0x75, 0xc3, 0x77, 0xc3, 0x79,
            ],
            decoded: "Ã‚ÄˆÃŠÄœÄ¤ÃÄ´Ã”ÅœÃ›Å´Å¶Ã¢Ä‰ÃªÄÄ¥Ã®ÄµÃ´ÅÃ»ÅµÅ·",
        },
        TestData {
            encoded: &[
                0xc4, 0x41, 0xc4, 0x49, 0xc4, 0x4e, 0xc4, 0x4f, 0xc4, 0x55, 0xc4, 0x61, 0xc4, 0x69,
                0xc4, 0x6e, 0xc4, 0x6f, 0xc4, 0x75,
            ],
            decoded: "ÃƒÄ¨Ã‘Ã•Å¨Ã£Ä©Ã±ÃµÅ©",
        },
        TestData {
            encoded: &[
                0xc5, 0x41, 0xc5, 0x45, 0xc5, 0x49, 0xc5, 0x4f, 0xc5, 0x55, 0xc5, 0x61, 0xc5, 0x65,
                0xc5, 0x69, 0xc5, 0x6f, 0xc5, 0x75,
            ],
            decoded: "Ä€Ä’ÄªÅŒÅªÄÄ“Ä«ÅÅ«",
        },
        TestData {
            encoded: &[
                0xc6, 0x41, 0xc6, 0x47, 0xc6, 0x55, 0xc6, 0x61, 0xc6, 0x67, 0xc6, 0x75,
            ],
            decoded: "Ä‚ÄÅ¬ÄƒÄŸÅ­",
        },
        TestData {
            encoded: &[
                0xc7, 0x43, 0xc7, 0x45, 0xc7, 0x47, 0xc7, 0x49, 0xc7, 0x5a, 0xc7, 0x63, 0xc7, 0x65,
                0xc7, 0x67, 0xc7, 0x7a,
            ],
            decoded: "ÄŠÄ–Ä Ä°Å»Ä‹Ä—Ä¡Å¼",
        },
        TestData {
            encoded: &[
                0xc8, 0x41, 0xc8, 0x45, 0xc8, 0x49, 0xc8, 0x4f, 0xc8, 0x55, 0xc8, 0x59, 0xc8, 0x61,
                0xc8, 0x65, 0xc8, 0x69, 0xc8, 0x6f, 0xc8, 0x75, 0xc8, 0x79,
            ],
            decoded: "Ã„Ã‹ÃÃ–ÃœÅ¸Ã¤Ã«Ã¯Ã¶Ã¼Ã¿",
        },
        TestData {
            encoded: &[0xca, 0x41, 0xca, 0x55, 0xca, 0x61, 0xca, 0x75],
            decoded: "Ã…Å®Ã¥Å¯",
        },
        TestData {
            encoded: &[
                0xcb, 0x43, 0xcb, 0x47, 0xcb, 0x4b, 0xcb, 0x4c, 0xcb, 0x4e, 0xcb, 0x52, 0xcb, 0x53,
                0xcb, 0x54, 0xcb, 0x63, 0xcb, 0x6b, 0xcb, 0x6c, 0xcb, 0x6e, 0xcb, 0x72, 0xcb, 0x73,
                0xcb, 0x74,
            ],
            decoded: "Ã‡Ä¢Ä¶Ä»Å…Å–ÅÅ¢Ã§Ä·Ä¼Å†Å—ÅŸÅ£",
        },
        TestData {
            encoded: &[0xcd, 0x4f, 0xcd, 0x55, 0xcd, 0x6f, 0xcd, 0x75],
            decoded: "ÅÅ°Å‘Å±",
        },
        TestData {
            encoded: &[
                0xce, 0x41, 0xce, 0x45, 0xce, 0x49, 0xce, 0x55, 0xce, 0x61, 0xce, 0x65, 0xce, 0x69,
                0xce, 0x75,
            ],
            decoded: "Ä„Ä˜Ä®Å²Ä…Ä™Ä¯Å³",
        },
        TestData {
            encoded: &[
                0xcf, 0x43, 0xcf, 0x44, 0xcf, 0x45, 0xcf, 0x4c, 0xcf, 0x4e, 0xcf, 0x52, 0xcf, 0x53,
                0xcf, 0x54, 0xcf, 0x5a, 0xcf, 0x63, 0xcf, 0x64, 0xcf, 0x65, 0xcf, 0x6c, 0xcf, 0x6e,
                0xcf, 0x72, 0xcf, 0x73, 0xcf, 0x74, 0xcf, 0x7a,
            ],
            decoded: "ÄŒÄÄšÄ½Å‡Å˜Å Å¤Å½ÄÄÄ›Ä¾ÅˆÅ™Å¡Å¥Å¾",
        },
    ];

    let mut buf = [0u8; 512];

    for test in tests {
        let enc = iso6937::encode(&test.decoded);
        assert_eq!(enc.as_slice(), test.encoded);

        let len = iso6937::encode_to_slice(&test.decoded, &mut buf);
        assert_eq!(enc, &buf[.. len]);
    }

    for test in tests {
        let dec = iso6937::decode(test.encoded);
        assert_eq!(test.decoded, dec.as_str());

        let len = iso6937::decode_to_slice(test.encoded, &mut buf);
        assert_eq!(dec.as_bytes(), &buf[.. len]);
    }
}

#[test]
fn test_iso6937_buffer_overflow() {
    // encode_to_slice: buffer too small for result
    let src = "Ã€ÃˆÃŒ"; // 3 characters, each encodes to 2 bytes = 6 bytes
    let mut small_buf = [0u8; 4];
    let len = iso6937::encode_to_slice(src, &mut small_buf);
    assert_eq!(len, 0);

    // encode_to_slice: buffer large enough
    let mut big_buf = [0u8; 16];
    let len = iso6937::encode_to_slice(src, &mut big_buf);
    assert_eq!(len, 6);

    // decode_to_slice: buffer too small for result
    let encoded = &[0xc1, 0x41, 0xc1, 0x45, 0xc1, 0x49]; // Ã€ÃˆÃŒ
    let mut small_buf = [0u8; 4];
    let len = iso6937::decode_to_slice(encoded, &mut small_buf);
    assert_eq!(len, 0);

    // decode_to_slice: buffer large enough
    let mut big_buf = [0u8; 16];
    let len = iso6937::decode_to_slice(encoded, &mut big_buf);
    assert_eq!(len, 6); // 3 characters, 2 bytes each in UTF-8
}

#[test]
fn test_iso6937_fallback() {
    // encode_fallback: character outside ISO 6937 is encoded as '?'
    let src = "Hello ğŸ˜€"; // emoji ğŸ˜€ is not supported
    let enc = iso6937::encode(src);
    assert_eq!(enc.as_slice(), b"Hello ?");

    // encode_fallback: cyrillic characters are not supported in ISO 6937
    let src = "Ğ¢ĞµÑÑ‚"; // cyrillic
    let enc = iso6937::encode(src);
    assert_eq!(enc.as_slice(), b"????");

    // decode_fallback: invalid diacritical sequence
    // 0xC1 - diacritical mark, but followed by invalid character
    let encoded = &[0x48, 0x69, 0xC1, 0x21, 0x21]; // "Hi" + diacritical + '!!'
    let dec = iso6937::decode(encoded);
    assert_eq!(dec.as_str(), "Hiï¿½!");
}
